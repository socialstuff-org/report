%!TEX root = ../report.tex
\chapter{Implementation}\label{ch:implementation}

% TODO @all add introduction to implementation
\lipsum[2-4]

\section{Trale Libraries}\label{sec:libraries}
In the project, we tried to re-use as much code as possible.
Sine the client and server-side projects are both implemented in TypeScript, we moved shared logic between the projects into separate libraries.

Each library serves a different purpose in the Trale system, and is in-fact independent from each other.
Code contained in the libraries is more of a general approach to solve a certain problem.
Through delegation of specific tasks, the library stays flexible, while the concrete way of performing a task is implemented in the actual client application.
I.e. you may want to store data in an encrypted manner, so the library will take care of applying an encryption algorithm, while the consumer of the library provides the specific algorithm to be used.

However, due to some constraints of the TypeScript compiler, working with these libraries didn't work by creating a local connection to the package, but we had to upload them to npm and install them afterwards.
This lead to some issues in the development process, such as version mismatches between the server and client, where both had to use the newest version, but one was using an older version.
% TODO rename this chapter to make clear that the libraries are self-developed
% TODO @all add introduction to libraries
% -> why libraries?
% -> advantages?
% -> disadvantages?

\subsection{Transport}\label{subsec:transport}
One of the big questions during the project was: how can we get data (messages) from one client to another one and temporarily save data, which shall be sent to a user who is currently offline?
The former part of this question will be addressed by the Transport library, whilst the latter part is delegated to the library consumer, i.e. the node.js based chat server.

The Transport library, as the name suggests, is responsible for getting transporting data from one client to another (technically from a client to a server, and then to another client).
It only provides transport security for client-server connections!
The actual content of a message packet has to be properly encrypted by the client!

% TODO @joernneumeyer & @mauritsvanderzee
% TODO add link to npm
\subsubsection{Establishing a Secure Client-Server Connection}
Although the content, and most meta data (e.g. time sent, sender name) of messages shall be encrypted by clients, some data has to be apparent to the server, in order to have the ability to forward the message to the proper recipient.

In order to establish a secure connection between a client and a server, both parties must be in possession of the following things:
\begin{itemize}
  \item a \ac{ECDH} public and private key pair
  \item a RSA public and private key pair
\end{itemize}


\subsection{Persistence}\label{subsec:persistence}
Security by means of encryption does not only apply to the transport step of data, but also to the way data is persisted.
However, it would be quite redundant to always manually specify the full path to a file one wants to operate on or the way data should be encrypted and decrypted.
Therefore, we created an abstraction to address these issues.

The persistence library offers a simple API to instantiate a so called \enquote{CryptoStorage}, which performs its operations on a given base directory with user-specifiable encryption algorithms.
Given a base directory, one can now easily perform operations relative to that directory without being bothered to know the actual full path.

The two most fundamental operation revolve around saving files in an encrypted manner and loading them from the local storage and retrieving the encrypted data in plain text again.
Additionally, another API for so called \enquote{TextRecordStorage}s is provided to stream the content of a file containing multiple sub-records.

\subsubsection{Streaming File Content - TextRecordStorage}
A \enquote{TextRecordStorage} is a helper, which stores multiple pieces of data in a text based format in one file.
This functionality could also be achieved using functions of the \enquote{CryptoStorage}, but the \enquote{TextRecordStorage} provides an important feature, which is missing in the \enquote{CryptoStorage}: streaming the content of a file instead of fully loading it in one go.
But why is this important?

One implication of a messenger, which is frequently used by a user, is, that over time a lot of messages will be accumulated in chat logs one has with varying chat partners.
These chat logs may become so large that they won't fit into a client's memory (RAM) at once.
Therefore the need to load message on an on-demand basis.

To achieve this on-demand loading, the \enquote{TextRecordStorage} loads the specified file in chunks (meaning smaller parts).
Next, each chunk will be checked, if it contains a full record.
If that's not the case, the next chunk will be loaded and concatenated with the previous one.
This process is repeated until the next record has been fully loaded.
As soon as this happens, the new record will be returned.

One important remark: all of the described (record) loading will only take place if a new record is requested.
If no are requested, no data will be loaded and the machines memory will not be utilized unnecessarily.
% TODO @joernneumeyer & @mauritsvanderzee
% TODO add link to npm

\subsection{Utilities}\label{subsec:utilities}
% TODO @joernneumeyer & @mauritsvanderzee
% TODO add link to npm

\section{Frontend}\label{sec:frontend}

\subsection{Services}\label{subsec:services}

\subsubsection{API Service}\label{subsubsec:api-service}
The API service is a rather small service located in the desktop client.
The service is responsible for managing the global state of all relevant API information in the desktop application.
In the current state of development this includes the following information

\begin{itemize}
    \item hostname - the hostname of the server (e.g. trale.org)
    \item port - the default port on which the service is listening for incoming connections (default: 8086)
    \item the remote endpoint - a constructed string for building a connection to the server (e.g.\ http://trale.org:8086)
    \item trale port - the default port on which the service is listening for encrypted messages (default: 8087)
\end{itemize}

Further, the service provides several helper methods for retrieving and updating the remote endpoint as well as several
getters and setters for all above mentioned attributes.

\subsubsection{Auth Service}\label{subsubsec:auth-service}
The auth service is responsible for managing authentication related tasks such as login, logout, registration and
minor helper functions (e.g.\ forgot password).

\paragraph{Login function}
The login takes a username and a password as parameters and executes a post request to the remote endpoint specified in
the \textbf{\hyperref[subsubsec:api-service]{API service}}.
On a successful login a token will be provided for future authentication, otherwise an error stating 'Invalid
credentials - Status code 400' will be returned.

% TODO @joernneumeyer maybe add register / logout etc. here as well? refactor code? not in auth service yet

Due to the mentioned responsibilities, this service is only injected in authentication related components.

\subsubsection{Contact Service}\label{subsubsec:contact-service}

The contact service is responsible for managing all contact related tasks and corresponding state management.
It owns a contact array holding all contacts for the currently logged-in user.
On application startup the contact service will load all contacts from drive by utilizing the
\textbf{\hyperref[subsubsec:crypto-storage-service]{Crypto Storage Service}}.

Besides providing a loading wrapper for retrieving encrypted contacts from the drive it also manages actions such as
adding contacts, updating contacts or fetching the latest message of all contacts to display those in the contact list.

Lastly, the contact service provides a function to load the actual chat of a specific contact with the currently
logged-in user.

% TODO @joernneumeyer any additional remarks / information to be added?

\subsubsection{Debug Service?}
% TODO @joernneumeyer & @mauritsvanderzee
% @joernneumeyer shall we include debug service?

\subsubsection{Crypto Storage Service}
% TODO @joernneumeyer & @mauritsvanderzee

\subsubsection{Key Registry Service}
% TODO @joernneumeyer & @mauritsvanderzee

\subsubsection{Titp Service}
% TODO @joernneumeyer & @mauritsvanderzee

\subsubsection{Util Service}
% TODO @mauritsvanderzee

\subsection{Components}

\section{Backend}

\subsection{Database Connections}

\subsection{Services}

\subsubsection{Authentication Service}
% TODO @joernneumeyer

\subsubsection{File Service}
% TODO @all shall we just briefly mention that this might be a service for future features / development

\subsubsection{Identity Service}
% TODO @joernneumeyer

\subsubsection{Settings Service}
% TODO @maltecastner & tobiasjansen
