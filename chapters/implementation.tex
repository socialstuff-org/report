%!TEX root = ../report.tex


\chapter{Implementation}\label{ch:implementation}
As Trale is designed with decentralization, flexibility, and micro-services in mind, the implementation had to be split
into several parts.
This chapter will explain these parts as well as their functionalities.

\section{Frontend}\label{sec:frontend}

\subsection{Services}\label{subsec:services}

The following part of the report will cover the different frontend services which have been developed during the
project.
By \textit{service} we refer to Angular services which enable automated dependency injection as well as application
wide state management.

\subsubsection{API Service}\label{subsubsec:api-service}

The \ac{api} service is a rather small service located in the desktop client.
The service is responsible for managing the global state of all relevant \ac{api} information in the desktop
application.
In the current state of development this includes the following information:

\begin{itemize}\setlength\itemsep{-0.5em}
    \item hostname - the hostname of the server (e.g.\ trale.org)
    \item port - the default \ac{http} port on which the other services and comments may perform \ac{rest} calls
        (default: 8086)
    \item the remote endpoint - a constructed string for building a connection to the server
        (e.g.\ https://trale.org:8086)
    \item trale port - the default port on which the server is listening for encrypted connections (default: 8087)
\end{itemize}

Further, the service provides several helper methods for retrieving and updating the remote endpoint as well as several
getters and setters for all above mentioned attributes.

\subsubsection{Authentication Service}\label{subsubsec:auth-service}

The authentication service is responsible for managing authentication related tasks such as login, logout, registration
and minor helper functions (e.g.\ forgot password).

\paragraph{Login function}
The login takes a username and a password as parameters and executes a post request to the remote endpoint specified in
the \textbf{\hyperref[subsubsec:api-service]{API service}}.
On a successful login a token will be provided for future authentication, otherwise an error stating 'Invalid
credentials - Status code 400' will be returned.

\paragraph{Register function}
The registration takes username, a password and an optional invitation code (depending on the server settings) as
parameters.
Firstly, a new \ac{rsa} key pair is being generated with a length of 4096 bits.
A post request to the remote endpoint specified in the \textbf{\hyperref[subsubsec:api-service]{API service}} will be
performed containing the username, password, \ac{rsa} public key and invite code if one is necessary.

If the post request fails an error message will be displayed, and the function is done.
If its succeeds, the client will receive a response containing a token.
This token is a piece of data which has been encrypted by the server using the given \ac{rsa} public key, and it will
be decrypted by the client in order to prove ownership of the \ac{rsa} public key.

Secondly, a second \ac{rest} call will be made in order to confirm the registration (i.e.\ ownership of the \ac{rsa}
public key).
This is achieved by posting the decrypted token to the identity service.
If the registration is completed, the local crypto storage will be initialized and the \ac{rsa} public and private keys
are stored.

\subsubsection{Contact Service}\label{subsubsec:contact-service}

The contact service is responsible for managing all contact related tasks and corresponding state management.
It owns a contact array holding all contacts for the currently logged-in user.
On application startup the contact service will load all contacts from drive by utilizing the
\textbf{\hyperref[subsubsec:crypto-storage-service]{Crypto Storage Service}}.

Besides, providing a loading wrapper for retrieving encrypted contacts from the drive, it also manages actions such as
adding contacts, updating contacts or fetching the latest message of all contacts to display those in the sidenav.

Lastly, the contact service provides a function to load the actual chat (a text record storage) of a specific contact
with the currently logged-in user.

\subsubsection{Crypto Storage Service}

The crypto storage service implements a crypto provider (\ref{fig:figure38}) which specifies an encryption via \ac{aes}
with a 256bit key in cbc mode.
The service itself is a wrapper around the crypto storage library (\ref{fig:figure38}).
In addition, it provides a load function to initialize the underlying crypto storage instance for the user who is
currently logged in.
It also automatically generates a master password which is used for the actual encryption.
The user password however, is used to encrypt and decrypt that master password.

The service also provides several getters for retrieving the mentioned master key for external encryption operations as
well as the base directory and underlying crypto storage instance.

\subsubsection{Key Registry Service}

The key registry service implements both the conversation key registry, and the user key registry (\ref{fig:figure34}).

\paragraph{User Key Registration Implementation}
The user key registry is responsible for retrieving \ac{rsa} public keys from users.
It always tries to load the requested key from a build in cache for optimal performance.
In case the cache does not know the requested key, it will try to fetch the key from the contact service by loading
the corresponding contact.
If this operation succeeds the key will be added to the cache and returned to the one requesting it.
If the contact service is unable to provide the requested key, the user key registry will request the key from the
identity backend service.

This procedure saves a lot of time and resources, as it always tries to fetch the key in the best performant way
possible.

\paragraph{Conversation Key Registration Implementation}
The conversation key registry serves two main purposes.
Firstly, it is responsible for temporarily storing \ac{ecdh} private keys for key negotiation (handshake).
This is necessary because one may start a handshake with another user who is currently offline so the \ac{ecdh} private
key has to be temporarily stored since they are always regenerated, for security reasons, if the application is
restarted.

Secondly, storing of negotiated conversation keys with other users.
Assuming a contact already exists, this function will simply load the contact overwrite the conversation key and saves
the contact.
If that contact does not exist, the method will automatically create a new contact for the given username and
conversation key, and it also automatically loads the \ac{rsa} public key via the previously described
\textit{fetchRSA()} method.

\subsubsection{Titp Service}

The \ac{titp} service is technically a wrapper around the \ac{titp} client from
the~\hyperref[subsec:transport]{\textbf{transport library}}.
It is mainly responsible for initializing said instance with concrete parameters (i.e.\ username, \ac{rsa} key pair,
\ac{ecdh} key pair and key registries).

Additionally, it provides a \textit{connect()} method which is responsible for establishing a connection to the
\ac{titp} server.
Todo so it either loads existing / known values (e.g.\ the servers \ac{rsa} public key) or generates needed values like
the \ac{ecdh} key pair.
After establishing a connection to the \ac{titp} server, the underlying \ac{titp} client instance may be used to send
and receive data (i.e.\ messages).
The client also automatically notifies the consumer about connection state changes (going online or offline).

\subsection{Components}\label{subsec:components}

\subsubsection{Chat App Component}
The chat app component combines nearly all services with each other to an actual working chat application.
It listens to incoming messages from the \ac{titp} client via the \ac{titp} service.
This is done in order to properly add the incoming messages to the appropriate chat log if the sender of the message
exists as a contact.
It will also trigger push notifications in the frontend with a minimum of five seconds between the notifications if a
new message has been received.
This push notification will contain an adequate summary of the message (e.g.\ the beginning of a text message, or the
length of a voice message).

\subsubsection{Chat View Component}
The chat view component is contains the actual chat view, displaying all fetched chat messages from a chat log as well
as the sub-component \enquote{message box} which contains the actual logic of writing or recording (voice) a message.
However, it does not send the message directly, but it passes the full message to the chat view, which makes use of the
\ac{titp} service.

If a new incoming message is recognized, it will be added the chat view component and therefore displayed to the user.

\subsubsection{Sidenav Component}
The sidenav component displays all present contacts including the latest message of the corresponding chat log.
On an incoming message, the sidenav will update automatically, displaying the latest message.


% TODO @maltecastner admin panel components?

\section{Backend}\label{sec:backend}

The following part of the report will cover the different services which have been developed during the project.
This will include a description of each service, followed by a \ac{rest} \ac{api} specification.

\subsection{Database Connections}\label{subsec:database-connections}

For the project we used two database management systems, MongoDB and MySQL, depending on the requirements of the backend
services.

\subsubsection{MongoDB}
MongoDB is a non-relational, document based database management system.
This brings a few advantages ad disadvantages, depending on the use case.
MongoDB is best when you want the flexibility of schema.
You can easily use replica sets with MongoDB and can take advantage of scalability.
Expansion plans are flexible and can be easily achieved by adding more machines and RAM to the system.
It also includes document validations and integrated systems.

A big disadvantage of MongoDB is that over time the data size will increase drastically over time.
Compared to other DBMS systems the speed is comparatively low.

\paragraph{Why and where was MongoDB used?}
Mongo DB was used for the messages.
This is because the messages are non-relational data in the case of SocialStuff.
The disadvantage of low speed once the data amount increases is neglectable in the case of SocialStuff, as the data will
only be stored temporarily on the server.
The data amount is therefore not that high.
Of course local machines will still store the messages on a longer period, however as only the messages with chat
partners are stored the amount of data is still comparatively low.

Due to the high scalability of MongoDB it is excellent for SocialStuff, as the entire system is based on users adding
more servers to the system to increase the security of the system.

\subsubsection{MySQL}
MySQL is a relational database management system, this also features advantages and disadvantages.
For starters MySQL provides a high performance and runs on almost every system which is important for SocialStuff as
users will be able to setup the servers themselves.
Using MySQL will make this process simpler for them.
MySQL also provides a high security, because the database administrator can grant appropriate permissions to
applications that access stored procedures in the database without giving any permissions on the underlying database
tables.
A disadvantage of MySQL is that it becomes slower the more data is stored on it due to a high memory usage.

\paragraph{Why and where was MySQL used?}
MySQL was used for all the relational data, like the data used in the identity service (user data) and reporting
service.
This was done as this data is not mere transactional data (like the messages) but data that is meant to stay.
Furthermore, the high scalability will proof useful once the application will be used by more users and more than our
one test server is online.

\subsection{Services}\label{subsec:services2}

\subsubsection{Authentication Service}
% TODO @joernneumeyer

\subsubsection{File Service}
% TODO @all shall we just briefly mention that this might be a service for future features / development

\subsubsection{Identity Service}
\label{subsubsec:identitySer}
% TODO @joernneumeyer

\subsubsection{Settings Service}\label{subsubsec:settingsSer}

The Settings service provides an interface to the admin panel frontend and carries out the settings to the other
services.
This service was developed in parallel to the admin panel frontend. %TODO @maltecastner insert reference to component, once it has been added
First only the for the UI necessary functionality would be added, later on the actual functionality was added
(e.g.\ that users can actually be reported for the report reasons added in the settings).
As it can be seen from the use case diagram~\ref{fig:ucd} the settings service carries out a few tasks by itself whilst
forwarding certain other requests to the \hyperref[subsubsec:identitySer]{\textbf{identity service}} and the
\hyperref[subsubsec:reportingSer]{\textbf{reporting service}}.
The use cases as well as their descriptions are located in the
\hyperref[ch:software-requirements-specification-(srs)]{\textbf{\ac{srs}}}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1.0\textwidth]{./images/UseCaseDiagramAdminPanel}
    \caption{Use case diagram of the admin panel showing responsibility of each AP service}
    \label{fig:ucd}
\end{figure}

\paragraph{Rest interface}

The settings service provides the following \ac{rest} endpoints:

\begin{lstlisting}[label={lst:lstlisting}]
GET: /settings/report-reason
\end{lstlisting}

Returns all report reasons as a JSON array.

\begin{lstlisting}[label={lst:lstlisting2}]
POST: /settings/report-reason
body:
{
"reason": "some reason",
"max_report_violations": 5
}
\end{lstlisting}

Adds a new report reason.

\begin{lstlisting}[label={lst:lstlisting3}]
PUT: /settings/report-reason
body:
{
"id": 123,
"reason": "some reason",
"max_report_violations": 5
}
\end{lstlisting}

Edits an existing report reason.

\begin{lstlisting}[label={lst:lstlisting4}]
DELETE: /settings/report-reason
headers:
- "id": 123
\end{lstlisting}

Deletes a report reason with an id that is provided as a header.

\begin{lstlisting}[label={lst:lstlisting5}]
GET: /settings/security
\end{lstlisting}

Returns the current security settings.

\begin{lstlisting}[label={lst:lstlisting6}]
PUT: /settings/security
body:
{
    "two_factor_auth": {
    "on" : true,
    "phone": false,
    "email": true
},
    "confirmed_emails_only": true,
    "individual_pwd_req": {
    "on": true,
    "upper_case": true,
    "number": true,
    "special_char": true,
    "reg_ex": false,
    "reg_ex_string": "[]"
},
    "inv_only": {
        "on": false,
        "inv_only_by_adm": false
    }
}
\end{lstlisting}

Edits the security settings.
The new settings are provided in body.

\paragraph{Example add report reason}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1.0\textwidth]{./images/SequenceDiagram_AddReportReason}
    \caption{Use case diagram of the admin panel showing responsibility of each AP service}
    \label{fig:addReportReason}
\end{figure}

The sequence diagram~\ref{fig:addReportReason} shows an example of the communication of the settings service with the
aforementioned services.
The event is triggered by a request from the client.
Firstly the settings service will be verifying the identity of the sender by checking at the identity service, if the
user who sent out the request is in fact an administrator.
Then the request will e forwarded to the reporting service.
Here it will be checked if the request format is valid.
Should this not be the case, the reporting service will return an error (status 400).
Otherwise, the reason will be added in the reporting database, which will then be returned to the settings service,
who will then let the client know by response that the insertion was a success.
This way each service has a clearly defined task.

\subsubsection{Reporting Service}\label{subsubsec:reportingSer}

The reporting service handles the reporting system.
This includes administrative tasks like managing for which reasons users can be reported, as well as the reporting
system itself (reporting users and banning them).
The administrative tasks, like adding new report reasons, manually blocking and unblocking users, can be done via the
\hyperref[subsubsec:settingsSer]{\textbf{settings service}}.
This service was added in the latter stages of the project.

First the entire reporting was handled via the \hyperref[subsubsec:settingsSer]{\textbf{settings service}}, however it
was decided that the reporting itself should possess its own service.
The reason for this being that we early on decided to build the application in a modular manner, so users can decide
which services they want to have and which once they do not.
It could be that some users do not want to have a reporting service.
Therefore, it was necessary to outsource the report related functionality from the
\hyperref[subsubsec:settingsSer]{\textbf{settings service}} to the
\hyperref[subsubsec:reportingSer]{\textbf{reporting service}}.

\paragraph{Rest Interface}
\begin{lstlisting}[label={lst:lstlisting7}]
POST: /report-reasons
body:
{
    "reason": "some reason",
    "max_report_violations": 5
}
\end{lstlisting}

Adds a new report reason returning the ID of the added report reason.

\begin{lstlisting}[label={lst:lstlisting8}]
PUT: /report-reasons
body:
{
    "id": 12
    "reason": "some reason",
    "max_report_violations": 5
}
\end{lstlisting}

Edits a report reason by the \enquote{ID} key and returns the edited reason.

\begin{lstlisting}[label={lst:lstlisting9}]
GET: /report-reasons
\end{lstlisting}

Returns all existing report reasons as JSON array

\begin{lstlisting}[label={lst:lstlisting10}]
DELETE: /report-reasons
headers
    - id: 12
\end{lstlisting}

Deletes a report reason by ID which is provided in the header of the request.
Returns the ID of the deleted request in its body.

\begin{lstlisting}[label={lst:lstlisting11}]
Headers:
    - user_token
Body:
{
    "username": "userHashOfUserBeingReported",
    "reason_id": 123
}
\end{lstlisting}

Reports a user based of the report reason, and the users' username hash.
A user can only be reported by the same user for the same reason after 15 minutes to prevent spamming.
Otherwise, the report will be processed by the backend, and the user will be set to \enquote{blocked} in case one
exceeds the maximum report violation counter.

